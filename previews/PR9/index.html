<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Numerical Data · StateSpaceSets.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>StateSpaceSets.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Numerical Data</a><ul class="internal"><li><a class="tocitem" href="#Datasets"><span>Datasets</span></a></li><li><a class="tocitem" href="#Dataset-Functions"><span>Dataset Functions</span></a></li><li><a class="tocitem" href="#Dataset-distances"><span>Dataset distances</span></a></li><li><a class="tocitem" href="#Dataset-I/O"><span>Dataset I/O</span></a></li><li><a class="tocitem" href="#Neighborhoods"><span>Neighborhoods</span></a></li><li><a class="tocitem" href="#Theiler-window"><span>Theiler window</span></a></li><li><a class="tocitem" href="#Samplers"><span>Samplers</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Numerical Data</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Numerical Data</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/main/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Numerical-Data"><a class="docs-heading-anchor" href="#Numerical-Data">Numerical Data</a><a id="Numerical-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-Data" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="StateSpaceSets" href="#StateSpaceSets"><code>StateSpaceSets</code></a> — <span class="docstring-category">Module</span></header><section><div><p>A Julia package that provides an interface for datasets, or more specifically, state space sets. These are collections of points of fixed, and known by type, size (called dimension). The main export of the package is the <a href="#StateSpaceSets.Dataset"><code>Dataset</code></a> type, and all its surrounding convenience functions. It is used in several projects in the JuliaDynamics organization, such as <a href="https://juliadynamics.github.io/DynamicalSystems.jl/dev/">DynamicalSystems.jl</a> or <a href="https://juliadynamics.github.io/CausalityTools.jl/dev/">CausalityTools.jl</a>.</p><p>To install it, run <code>import Pkg; Pkg.add(&quot;StateSpaceSets&quot;)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/eb53eb19925c709191d89e2b0bd738e9b86bde60/src/StateSpaceSets.jl#L1-L10">source</a></section></article><div class="admonition is-info"><header class="admonition-header">Timeseries and datasets</header><div class="admonition-body"><p>The word &quot;timeseries&quot; can be confusing, because it can mean a univariate (also called scalar or one-dimensional) timeseries or a multivariate (also called multi-dimensional) timeseries. To resolve this confusion, in <strong>DynamicalSystems.jl</strong> we have the following convention: <strong>&quot;timeseries&quot;</strong> is always univariate! it refers to a one-dimensional vector of numbers, which exists with respect to some other one-dimensional vector of numbers that corresponds to a time vector. On the other hand, we use the word <strong>&quot;dataset&quot;</strong> is used to refer to a <em>multi-dimensional</em> timeseries, which is of course simply a group/set of one-dimensional timeseries represented as a <a href="#StateSpaceSets.Dataset"><code>Dataset</code></a>. In some documentation strings we use the word &quot;trajectory&quot; instead of &quot;dataset&quot;, which means an ordered multivariate timeseries. This is typically the output of the function <a href="@ref"><code>trajectory</code></a>, or the delay embedding of a timeseries via <a href="@ref"><code>embed</code></a>, both of which are also represented as a <a href="#StateSpaceSets.Dataset"><code>Dataset</code></a>.</p></div></div><h2 id="Datasets"><a class="docs-heading-anchor" href="#Datasets">Datasets</a><a id="Datasets-1"></a><a class="docs-heading-anchor-permalink" href="#Datasets" title="Permalink"></a></h2><p>Trajectories, and in general sets in state space, are represented by a structure called <code>Dataset</code> in <strong>DynamicalSystems.jl</strong> (while timeseries are always standard Julia <code>Vector</code>s). It is recommended to always <a href="#StateSpaceSets.standardize"><code>standardize</code></a> datasets.</p><article class="docstring"><header><a class="docstring-binding" id="StateSpaceSets.Dataset" href="#StateSpaceSets.Dataset"><code>StateSpaceSets.Dataset</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Dataset{D, T} &lt;: AbstractDataset{D,T}</code></pre><p>A dedicated interface for datasets. It contains <em>equally-sized datapoints</em> of length <code>D</code>, represented by <code>SVector{D, T}</code>. These data are a standard Julia <code>Vector{SVector}</code>, and can be obtained with <code>vec(dataset)</code>.</p><p>When indexed with 1 index, a <code>dataset</code> is like a vector of datapoints. When indexed with 2 indices it behaves like a matrix that has each of the columns be the timeseries of each of the variables.</p><p><code>Dataset</code> also supports most sensible operations like <code>append!, push!, hcat, eachrow</code>, among others, and when iterated over, it iterates over its contained points.</p><p><strong>Description of indexing</strong></p><p>In the following let <code>i, j</code> be integers,  <code>typeof(data) &lt;: AbstractDataset</code> and <code>v1, v2</code> be <code>&lt;: AbstractVector{Int}</code> (<code>v1, v2</code> could also be ranges, and for massive performance benefits make <code>v2</code> an <code>SVector{X, Int}</code>).</p><ul><li><code>data[i] == data[i, :]</code> gives the <code>i</code>th datapoint (returns an <code>SVector</code>)</li><li><code>data[v1] == data[v1, :]</code>, returns a <code>Dataset</code> with the points in those indices.</li><li><code>data[:, j]</code> gives the <code>j</code>th variable timeseries, as <code>Vector</code></li><li><code>data[v1, v2], data[:, v2]</code> returns a <code>Dataset</code> with the appropriate entries (first indices being &quot;time&quot;/point index, while second being variables)</li><li><code>data[i, j]</code> value of the <code>j</code>th variable, at the <code>i</code>th timepoint</li></ul><p>Use <code>Matrix(dataset)</code> or <code>Dataset(matrix)</code> to convert. It is assumed that each <em>column</em> of the <code>matrix</code> is one variable. If you have various timeseries vectors <code>x, y, z, ...</code> pass them like <code>Dataset(x, y, z, ...)</code>. You can use <code>columns(dataset)</code> to obtain the reverse, i.e. all columns of the dataset in a tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/eb53eb19925c709191d89e2b0bd738e9b86bde60/src/dataset.jl#L145-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceSets.standardize" href="#StateSpaceSets.standardize"><code>StateSpaceSets.standardize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">standardize(d::Dataset) → r</code></pre><p>Create a standardized version of the input dataset where each timeseries (column) is transformed to have mean 0 and standard deviation 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/eb53eb19925c709191d89e2b0bd738e9b86bde60/src/dataset.jl#L360-L364">source</a></section><section><div><pre><code class="nohighlight hljs">standardize(x::Timeseries) = (x - mean(x))/std(x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/eb53eb19925c709191d89e2b0bd738e9b86bde60/src/timeseries.jl#L17-L19">source</a></section></article><p>In essence a <code>Dataset</code> is simply a wrapper for a <code>Vector</code> of <code>SVector</code>s. However, it is visually represented as a matrix, similarly to how numerical data would be printed on a spreadsheet (with time being the <em>column</em> direction). It also offers a lot more functionality than just pretty-printing. Besides the examples in the documentation string, you can e.g. iterate over data points</p><pre><code class="language-julia hljs">using DynamicalSystems
hen = Systems.henon()
data = trajectory(hen, 10000) # this returns a dataset
for point in data
    # stuff
end</code></pre><p>Most functions from <strong>DynamicalSystems.jl</strong> that manipulate and use multidimensional data are expecting a <code>Dataset</code>. This allows us to define efficient methods that coordinate well with each other, like e.g. <a href="@ref"><code>embed</code></a>.</p><h2 id="Dataset-Functions"><a class="docs-heading-anchor" href="#Dataset-Functions">Dataset Functions</a><a id="Dataset-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Dataset-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StateSpaceSets.minima" href="#StateSpaceSets.minima"><code>StateSpaceSets.minima</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">minima(dataset)</code></pre><p>Return an <code>SVector</code> that contains the minimum elements of each timeseries of the dataset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/eb53eb19925c709191d89e2b0bd738e9b86bde60/src/dataset.jl#L283-L287">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceSets.maxima" href="#StateSpaceSets.maxima"><code>StateSpaceSets.maxima</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">maxima(dataset)</code></pre><p>Return an <code>SVector</code> that contains the maximum elements of each timeseries of the dataset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/eb53eb19925c709191d89e2b0bd738e9b86bde60/src/dataset.jl#L300-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceSets.minmaxima" href="#StateSpaceSets.minmaxima"><code>StateSpaceSets.minmaxima</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">minmaxima(dataset)</code></pre><p>Return <code>minima(dataset), maxima(dataset)</code> without doing the computation twice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/eb53eb19925c709191d89e2b0bd738e9b86bde60/src/dataset.jl#L317-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceSets.columns" href="#StateSpaceSets.columns"><code>StateSpaceSets.columns</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">columns(dataset) -&gt; x, y, z, ...</code></pre><p>Return the individual columns of the dataset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/eb53eb19925c709191d89e2b0bd738e9b86bde60/src/dataset.jl#L65-L68">source</a></section></article><h2 id="Dataset-distances"><a class="docs-heading-anchor" href="#Dataset-distances">Dataset distances</a><a id="Dataset-distances-1"></a><a class="docs-heading-anchor-permalink" href="#Dataset-distances" title="Permalink"></a></h2><h3 id="Two-datasets"><a class="docs-heading-anchor" href="#Two-datasets">Two datasets</a><a id="Two-datasets-1"></a><a class="docs-heading-anchor-permalink" href="#Two-datasets" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="StateSpaceSets.dataset_distance" href="#StateSpaceSets.dataset_distance"><code>StateSpaceSets.dataset_distance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dataset_distance(dataset1, dataset2 [, method])</code></pre><p>Calculate a distance between two <code>AbstractDatasets</code>, i.e., a distance defined between sets of points, as dictated by <code>method</code>.</p><p>The possible <code>methods</code> are:</p><ul><li><a href="#StateSpaceSets.Centroid"><code>Centroid</code></a>, which is the default, and 100s of times faster than the rest</li><li><a href="#StateSpaceSets.Hausdorff"><code>Hausdorff</code></a></li><li><a href="@ref"><code>StrictlyMinimumDistance</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/eb53eb19925c709191d89e2b0bd738e9b86bde60/src/dataset_distance.jl#L7-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceSets.Hausdorff" href="#StateSpaceSets.Hausdorff"><code>StateSpaceSets.Hausdorff</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Hausdorff(metric = Euclidean())</code></pre><p>A dataset distance that can be used in <a href="#StateSpaceSets.dataset_distance"><code>dataset_distance</code></a>. The <a href="https://en.wikipedia.org/wiki/Hausdorff_distance">Hausdorff distance</a> is the greatest of all the distances from a point in one set to the closest point in the other set. The distance is calculated with the metric given to <code>Hausdorff</code> which defaults to Euclidean.</p><p><code>Hausdorff</code> is 2x slower than <a href="@ref"><code>StrictlyMinimumDistance</code></a>, however it is a proper metric in the space of sets of datasets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/eb53eb19925c709191d89e2b0bd738e9b86bde60/src/dataset_distance.jl#L39-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceSets.Centroid" href="#StateSpaceSets.Centroid"><code>StateSpaceSets.Centroid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Centroid(metric = Euclidean())</code></pre><p>A dataset distance that can be used in <a href="#StateSpaceSets.dataset_distance"><code>dataset_distance</code></a>. The <code>Centroid</code> method returns the distance (according to <code>metric</code>) between the <a href="https://en.wikipedia.org/wiki/Centroid">centroids</a> (a.k.a. center of mass) of the datasets.</p><p>Besides giving as <code>metric</code> an instance from Distances.jl, you can give any function that takes in two static vectors are returns a positive definite number to use as a distance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/eb53eb19925c709191d89e2b0bd738e9b86bde60/src/dataset_distance.jl#L19-L27">source</a></section></article><h3 id="Sets-of-datasets"><a class="docs-heading-anchor" href="#Sets-of-datasets">Sets of datasets</a><a id="Sets-of-datasets-1"></a><a class="docs-heading-anchor-permalink" href="#Sets-of-datasets" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="StateSpaceSets.datasets_sets_distances" href="#StateSpaceSets.datasets_sets_distances"><code>StateSpaceSets.datasets_sets_distances</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">datasets_sets_distances(a₊, a₋ [, method]) → distances</code></pre><p>Calculate distances between sets of <code>Dataset</code>s. Here  <code>a₊, a₋</code> are containers of <code>Dataset</code>s, and the returned distances are dictionaries of of distances. Specifically, <code>distances[i][j]</code> is the distance of the dataset in the <code>i</code> key of <code>a₊</code> to the <code>j</code> key of <code>a₋</code>. Notice that distances from <code>a₋</code> to <code>a₊</code> are not computed at all (assumming symmetry in the distance function).</p><p>The <code>method</code> can be as in <a href="#StateSpaceSets.dataset_distance"><code>dataset_distance</code></a>. However, <code>method</code> can also be any arbitrary user function that takes as input two datasets and returns any positive-definite number as their &quot;distance&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/eb53eb19925c709191d89e2b0bd738e9b86bde60/src/dataset_distance.jl#L127-L138">source</a></section></article><h2 id="Dataset-I/O"><a class="docs-heading-anchor" href="#Dataset-I/O">Dataset I/O</a><a id="Dataset-I/O-1"></a><a class="docs-heading-anchor-permalink" href="#Dataset-I/O" title="Permalink"></a></h2><p>Input/output functionality for an <code>AbstractDataset</code> is already achieved using base Julia, specifically <code>writedlm</code> and <code>readdlm</code>. To write and read a dataset, simply do:</p><pre><code class="language-julia hljs">using DelimitedFiles

data = Dataset(rand(1000, 2))

# I will write and read using delimiter &#39;,&#39;
writedlm(&quot;data.txt&quot;, data, &#39;,&#39;)

# Don&#39;t forget to convert the matrix to a Dataset when reading
data = Dataset(readdlm(&quot;data.txt&quot;, &#39;,&#39;, Float64))</code></pre><h2 id="Neighborhoods"><a class="docs-heading-anchor" href="#Neighborhoods">Neighborhoods</a><a id="Neighborhoods-1"></a><a class="docs-heading-anchor-permalink" href="#Neighborhoods" title="Permalink"></a></h2><p>Neighborhoods refer to the common act of finding points in a dataset that are nearby a given point (which typically belongs in the dataset). <strong>DynamicalSystems.jl</strong> bases this interface on <a href="https://julianeighbors.github.io/Neighborhood.jl/dev/">Neighborhood.jl</a>. You can go to its documentation if you are interested in finding neighbors in a dataset for e.g. a custom algorithm implementation.</p><p>For <strong>DynamicalSystems.jl</strong>, what is relevant are the two types of neighborhoods that exist:</p><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>NeighborNumber</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>WithinRange</code>. Check Documenter&#39;s build log for details.</p></div></div><h2 id="Theiler-window"><a class="docs-heading-anchor" href="#Theiler-window">Theiler window</a><a id="Theiler-window-1"></a><a class="docs-heading-anchor-permalink" href="#Theiler-window" title="Permalink"></a></h2><p>The Theiler window is a concept that is useful when finding neighbors in a dataset that is coming from the sampling of a continuous dynamical system. As demonstrated in the figure below, it tries to eliminate spurious &quot;correlations&quot; (wrongly counted neighbors) due to a potentially dense sampling of the trajectory (e.g. by giving small sampling time in <a href="@ref"><code>trajectory</code></a>).</p><p>The figure below demonstrates a typical <code>WithinRange</code> search around the black point with index <code>i</code>. Black, red and green points are found neighbors, but points within indices <code>j</code> that satisfy <code>|i-j| ≤ w</code> should <em>not</em> be counted as &quot;true&quot; neighbors. These neighbors are typically the same around <em>any</em> state space point, and thus wrongly bias calculations by providing a non-zero baseline of neighbors. For the sketch below, <code>w=3</code> would have been used.</p><p>Typically a good choice for <code>w</code> coincides with the choice an optimal delay time, see <a href="@ref"><code>estimate_delay</code></a>, for any of the timeseries of the dataset.</p><p><img src="theiler.png" alt/></p><h2 id="Samplers"><a class="docs-heading-anchor" href="#Samplers">Samplers</a><a id="Samplers-1"></a><a class="docs-heading-anchor-permalink" href="#Samplers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StateSpaceSets.statespace_sampler" href="#StateSpaceSets.statespace_sampler"><code>StateSpaceSets.statespace_sampler</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">statespace_sampler(rng = Random.GLOBAL_RNG; kwargs...) → sampler, isinside</code></pre><p>Convenience function that creates two functions. <code>sampler</code> is a 0-argument function that generates random points inside a state space region defined by the keywords. <code>isinside</code> is a 1-argument function that decides returns <code>true</code> if the given state space point is inside that region.</p><p>The regions can be:</p><ul><li><strong>Rectangular box</strong>, with edges <code>min_bounds</code> and <code>max_bounds</code>. The sampling of the points inside the box is decided by the keyword <code>method</code> which can be either <code>&quot;uniform&quot;</code> or <code>&quot;multgauss&quot;</code>.</li><li><strong>Sphere</strong>, of <code>spheredims</code> dimensions, radius <code>radius</code> and centered on <code>center</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/eb53eb19925c709191d89e2b0bd738e9b86bde60/src/sampler.jl#L8-L20">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Sunday 29 January 2023 15:45">Sunday 29 January 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
