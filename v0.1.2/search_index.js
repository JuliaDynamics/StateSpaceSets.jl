var documenterSearchIndex = {"docs":
[{"location":"#Numerical-Data","page":"Numerical Data","title":"Numerical Data","text":"","category":"section"},{"location":"","page":"Numerical Data","title":"Numerical Data","text":"StateSpaceSets","category":"page"},{"location":"#StateSpaceSets","page":"Numerical Data","title":"StateSpaceSets","text":"A Julia package that provides an interface for datasets, or more specifically, state space sets. These are collections of points of fixed, and known by type, size (called dimension). The main export of the package is the Dataset type, and all its surrounding convenience functions. It is used in several projects in the JuliaDynamics organization, such as DynamicalSystems.jl or CausalityTools.jl.\n\nTo install it, run import Pkg; Pkg.add(\"StateSpaceSets\").\n\n\n\n\n\n","category":"module"},{"location":"","page":"Numerical Data","title":"Numerical Data","text":"info: Timeseries and datasets\nThe word \"timeseries\" can be confusing, because it can mean a univariate (also called scalar or one-dimensional) timeseries or a multivariate (also called multi-dimensional) timeseries. To resolve this confusion, in DynamicalSystems.jl we have the following convention: \"timeseries\" is always univariate! it refers to a one-dimensional vector of numbers, which exists with respect to some other one-dimensional vector of numbers that corresponds to a time vector. On the other hand, we use the word \"dataset\" is used to refer to a multi-dimensional timeseries, which is of course simply a group/set of one-dimensional timeseries represented as a Dataset. In some documentation strings we use the word \"trajectory\" instead of \"dataset\", which means an ordered multivariate timeseries. This is typically the output of the function trajectory, or the delay embedding of a timeseries via embed, both of which are also represented as a Dataset.","category":"page"},{"location":"#Datasets","page":"Numerical Data","title":"Datasets","text":"","category":"section"},{"location":"","page":"Numerical Data","title":"Numerical Data","text":"Trajectories, and in general sets in state space, are represented by a structure called Dataset in DynamicalSystems.jl (while timeseries are always standard Julia Vectors). It is recommended to always standardize datasets.","category":"page"},{"location":"","page":"Numerical Data","title":"Numerical Data","text":"Dataset\nstandardize","category":"page"},{"location":"#StateSpaceSets.Dataset","page":"Numerical Data","title":"StateSpaceSets.Dataset","text":"Dataset{D, T} <: AbstractDataset{D,T}\n\nA dedicated interface for datasets. It contains equally-sized datapoints of length D, represented by SVector{D, T}. These data are a standard Julia Vector{SVector}, and can be obtained with vec(dataset).\n\nWhen indexed with 1 index, a dataset is like a vector of datapoints. When indexed with 2 indices it behaves like a matrix that has each of the columns be the timeseries of each of the variables.\n\nDataset also supports most sensible operations like append!, push!, hcat, eachrow, among others, and when iterated over, it iterates over its contained points.\n\nDescription of indexing\n\nIn the following let i, j be integers,  typeof(data) <: AbstractDataset and v1, v2 be <: AbstractVector{Int} (v1, v2 could also be ranges, and for massive performance benefits make v2 an SVector{X, Int}).\n\ndata[i] == data[i, :] gives the ith datapoint (returns an SVector)\ndata[v1] == data[v1, :], returns a Dataset with the points in those indices.\ndata[:, j] gives the jth variable timeseries, as Vector\ndata[v1, v2], data[:, v2] returns a Dataset with the appropriate entries (first indices being \"time\"/point index, while second being variables)\ndata[i, j] value of the jth variable, at the ith timepoint\n\nUse Matrix(dataset) or Dataset(matrix) to convert. It is assumed that each column of the matrix is one variable. If you have various timeseries vectors x, y, z, ... pass them like Dataset(x, y, z, ...). You can use columns(dataset) to obtain the reverse, i.e. all columns of the dataset in a tuple.\n\n\n\n\n\n","category":"type"},{"location":"#StateSpaceSets.standardize","page":"Numerical Data","title":"StateSpaceSets.standardize","text":"standardize(d::Dataset) → r\n\nCreate a standardized version of the input dataset where each timeseries (column) is transformed to have mean 0 and standard deviation 1.\n\n\n\n\n\nstandardize(x::Timeseries) = (x - mean(x))/std(x)\n\n\n\n\n\n","category":"function"},{"location":"","page":"Numerical Data","title":"Numerical Data","text":"In essence a Dataset is simply a wrapper for a Vector of SVectors. However, it is visually represented as a matrix, similarly to how numerical data would be printed on a spreadsheet (with time being the column direction). It also offers a lot more functionality than just pretty-printing. Besides the examples in the documentation string, you can e.g. iterate over data points","category":"page"},{"location":"","page":"Numerical Data","title":"Numerical Data","text":"using DynamicalSystems\nhen = Systems.henon()\ndata = trajectory(hen, 10000) # this returns a dataset\nfor point in data\n    # stuff\nend","category":"page"},{"location":"","page":"Numerical Data","title":"Numerical Data","text":"Most functions from DynamicalSystems.jl that manipulate and use multidimensional data are expecting a Dataset. This allows us to define efficient methods that coordinate well with each other, like e.g. embed.","category":"page"},{"location":"#Dataset-Functions","page":"Numerical Data","title":"Dataset Functions","text":"","category":"section"},{"location":"","page":"Numerical Data","title":"Numerical Data","text":"minima\nmaxima\nminmaxima\ncolumns","category":"page"},{"location":"#StateSpaceSets.minima","page":"Numerical Data","title":"StateSpaceSets.minima","text":"minima(dataset)\n\nReturn an SVector that contains the minimum elements of each timeseries of the dataset.\n\n\n\n\n\n","category":"function"},{"location":"#StateSpaceSets.maxima","page":"Numerical Data","title":"StateSpaceSets.maxima","text":"maxima(dataset)\n\nReturn an SVector that contains the maximum elements of each timeseries of the dataset.\n\n\n\n\n\n","category":"function"},{"location":"#StateSpaceSets.minmaxima","page":"Numerical Data","title":"StateSpaceSets.minmaxima","text":"minmaxima(dataset)\n\nReturn minima(dataset), maxima(dataset) without doing the computation twice.\n\n\n\n\n\n","category":"function"},{"location":"#StateSpaceSets.columns","page":"Numerical Data","title":"StateSpaceSets.columns","text":"columns(dataset) -> x, y, z, ...\n\nReturn the individual columns of the dataset.\n\n\n\n\n\n","category":"function"},{"location":"#Dataset-distances","page":"Numerical Data","title":"Dataset distances","text":"","category":"section"},{"location":"#Two-datasets","page":"Numerical Data","title":"Two datasets","text":"","category":"section"},{"location":"","page":"Numerical Data","title":"Numerical Data","text":"dataset_distance\nHausdorff\nCentroid","category":"page"},{"location":"#StateSpaceSets.dataset_distance","page":"Numerical Data","title":"StateSpaceSets.dataset_distance","text":"dataset_distance(dataset1, dataset2 [, method])\n\nCalculate a distance between two AbstractDatasets, i.e., a distance defined between sets of points, as dictated by method.\n\nThe possible methods are:\n\nCentroid, which is the default, and 100s of times faster than the rest\nHausdorff\nStrictlyMinimumDistance\n\n\n\n\n\n","category":"function"},{"location":"#StateSpaceSets.Hausdorff","page":"Numerical Data","title":"StateSpaceSets.Hausdorff","text":"Hausdorff(metric = Euclidean())\n\nA dataset distance that can be used in dataset_distance. The Hausdorff distance is the greatest of all the distances from a point in one set to the closest point in the other set. The distance is calculated with the metric given to Hausdorff which defaults to Euclidean.\n\nHausdorff is 2x slower than StrictlyMinimumDistance, however it is a proper metric in the space of sets of datasets.\n\n\n\n\n\n","category":"type"},{"location":"#StateSpaceSets.Centroid","page":"Numerical Data","title":"StateSpaceSets.Centroid","text":"Centroid(metric = Euclidean())\n\nA dataset distance that can be used in dataset_distance. The Centroid method returns the distance (according to metric) between the centroids (a.k.a. center of mass) of the datasets.\n\nBesides giving as metric an instance from Distances.jl, you can give any function that takes in two static vectors are returns a positive definite number to use as a distance.\n\n\n\n\n\n","category":"type"},{"location":"#Sets-of-datasets","page":"Numerical Data","title":"Sets of datasets","text":"","category":"section"},{"location":"","page":"Numerical Data","title":"Numerical Data","text":"datasets_sets_distances","category":"page"},{"location":"#StateSpaceSets.datasets_sets_distances","page":"Numerical Data","title":"StateSpaceSets.datasets_sets_distances","text":"datasets_sets_distances(a₊, a₋ [, method]) → distances\n\nCalculate distances between sets of Datasets. Here  a₊, a₋ are containers of Datasets, and the returned distances are dictionaries of of distances. Specifically, distances[i][j] is the distance of the dataset in the i key of a₊ to the j key of a₋. Notice that distances from a₋ to a₊ are not computed at all (assumming symmetry in the distance function).\n\nThe method can be as in dataset_distance. However, method can also be any arbitrary user function that takes as input two datasets and returns any positive-definite number as their \"distance\".\n\n\n\n\n\n","category":"function"},{"location":"#Dataset-I/O","page":"Numerical Data","title":"Dataset I/O","text":"","category":"section"},{"location":"","page":"Numerical Data","title":"Numerical Data","text":"Input/output functionality for an AbstractDataset is already achieved using base Julia, specifically writedlm and readdlm. To write and read a dataset, simply do:","category":"page"},{"location":"","page":"Numerical Data","title":"Numerical Data","text":"using DelimitedFiles\n\ndata = Dataset(rand(1000, 2))\n\n# I will write and read using delimiter ','\nwritedlm(\"data.txt\", data, ',')\n\n# Don't forget to convert the matrix to a Dataset when reading\ndata = Dataset(readdlm(\"data.txt\", ',', Float64))","category":"page"},{"location":"#Neighborhoods","page":"Numerical Data","title":"Neighborhoods","text":"","category":"section"},{"location":"","page":"Numerical Data","title":"Numerical Data","text":"Neighborhoods refer to the common act of finding points in a dataset that are nearby a given point (which typically belongs in the dataset). DynamicalSystems.jl bases this interface on Neighborhood.jl. You can go to its documentation if you are interested in finding neighbors in a dataset for e.g. a custom algorithm implementation.","category":"page"},{"location":"","page":"Numerical Data","title":"Numerical Data","text":"For DynamicalSystems.jl, what is relevant are the two types of neighborhoods that exist:","category":"page"},{"location":"","page":"Numerical Data","title":"Numerical Data","text":"NeighborNumber\nWithinRange","category":"page"},{"location":"#Theiler-window","page":"Numerical Data","title":"Theiler window","text":"","category":"section"},{"location":"","page":"Numerical Data","title":"Numerical Data","text":"The Theiler window is a concept that is useful when finding neighbors in a dataset that is coming from the sampling of a continuous dynamical system. As demonstrated in the figure below, it tries to eliminate spurious \"correlations\" (wrongly counted neighbors) due to a potentially dense sampling of the trajectory (e.g. by giving small sampling time in trajectory).","category":"page"},{"location":"","page":"Numerical Data","title":"Numerical Data","text":"The figure below demonstrates a typical WithinRange search around the black point with index i. Black, red and green points are found neighbors, but points within indices j that satisfy |i-j| ≤ w should not be counted as \"true\" neighbors. These neighbors are typically the same around any state space point, and thus wrongly bias calculations by providing a non-zero baseline of neighbors. For the sketch below, w=3 would have been used.","category":"page"},{"location":"","page":"Numerical Data","title":"Numerical Data","text":"Typically a good choice for w coincides with the choice an optimal delay time, see estimate_delay, for any of the timeseries of the dataset.","category":"page"},{"location":"","page":"Numerical Data","title":"Numerical Data","text":"(Image: )","category":"page"},{"location":"#Samplers","page":"Numerical Data","title":"Samplers","text":"","category":"section"},{"location":"","page":"Numerical Data","title":"Numerical Data","text":"statespace_sampler","category":"page"},{"location":"#StateSpaceSets.statespace_sampler","page":"Numerical Data","title":"StateSpaceSets.statespace_sampler","text":"statespace_sampler(rng = Random.GLOBAL_RNG; kwargs...) → sampler, isinside\n\nConvenience function that creates two functions. sampler is a 0-argument function that generates random points inside a state space region defined by the keywords. isinside is a 1-argument function that decides returns true if the given state space point is inside that region.\n\nThe regions can be:\n\nRectangular box, with edges min_bounds and max_bounds. The sampling of the points inside the box is decided by the keyword method which can be either \"uniform\" or \"multgauss\".\nSphere, of spheredims dimensions, radius radius and centered on center.\n\n\n\n\n\n","category":"function"}]
}
