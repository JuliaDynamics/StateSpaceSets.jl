<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Numerical Data · StateSpaceSets.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script><link href="https://fonts.googleapis.com/css?family=Montserrat|Source+Code+Pro&amp;display=swap" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>StateSpaceSets.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Numerical Data</a><ul class="internal"><li><a class="tocitem" href="#StateSpaceSet"><span>StateSpaceSet</span></a></li><li><a class="tocitem" href="#StateSpaceSet-Functions"><span>StateSpaceSet Functions</span></a></li><li><a class="tocitem" href="#StateSpaceSet-distances"><span>StateSpaceSet distances</span></a></li><li><a class="tocitem" href="#StateSpaceSet-I/O"><span>StateSpaceSet I/O</span></a></li><li><a class="tocitem" href="#Neighborhoods"><span>Neighborhoods</span></a></li><li><a class="tocitem" href="#Theiler-window"><span>Theiler window</span></a></li><li><a class="tocitem" href="#Samplers"><span>Samplers</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Numerical Data</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Numerical Data</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/main/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Numerical-Data"><a class="docs-heading-anchor" href="#Numerical-Data">Numerical Data</a><a id="Numerical-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-Data" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="StateSpaceSets" href="#StateSpaceSets"><code>StateSpaceSets</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong>StateSpaceSets.jl</strong></p><p><a href="https://JuliaDynamics.github.io/StateSpaceSets.jl/dev"><img src="https://img.shields.io/badge/docs-dev-lightblue.svg" alt/></a> <a href="https://JuliaDynamics.github.io/StateSpaceSets.jl/stable"><img src="https://img.shields.io/badge/docs-stable-blue.svg" alt/></a> <a href="https://link.springer.com/book/10.1007/978-3-030-91032-7"><img src="https://img.shields.io/badge/DOI-10.1007%2F978--3--030--91032--7-purple" alt/></a> <a href="https://github.com/JuliaDynamics/StateSpaceSets.jl/actions?query=workflow%3ACI"><img src="https://github.com/JuliaDynamics/StateSpaceSets.jl/workflows/CI/badge.svg" alt="CI"/></a> <a href="https://codecov.io/gh/JuliaDynamics/StateSpaceSets.jl"><img src="https://codecov.io/gh/JuliaDynamics/StateSpaceSets.jl/branch/main/graph/badge.svg" alt="codecov"/></a> <a href="https://pkgs.genieframework.com?packages=StateSpaceSets"><img src="https://shields.io/endpoint?url=https://pkgs.genieframework.com/api/v1/badge/StateSpaceSets" alt="Package Downloads"/></a></p><p>A Julia package that provides functionality for state space sets. These are collections of points of fixed, and known by type, size (called dimension). It is used in several projects in the JuliaDynamics organization, such as <a href="https://juliadynamics.github.io/DynamicalSystems.jl/dev/">DynamicalSystems.jl</a> or <a href="https://juliadynamics.github.io/CausalityTools.jl/dev/">CausalityTools.jl</a>.</p><p>The main export of <code>StateSpaceSets</code> is the concrete type <code>StateSpaceSet</code>. The package also provides functionality for distances, neighbor searches, sampling, and normalization.</p><p>To install it you may run <code>import Pkg; Pkg.add(&quot;StateSpaceSets&quot;)</code>, however, there is no real reason to install this package directly as it is re-exported by all downstream packages that use it.</p><p><em>previously StateSpaceSets.jl was part of DelayEmbeddings.jl</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/61b726d27bb21a9ccc8238eae501988d86bad7a8/src/StateSpaceSets.jl#L4-L28">source</a></section></article><div class="admonition is-info"><header class="admonition-header">Timeseries and datasets</header><div class="admonition-body"><p>The word &quot;timeseries&quot; can be confusing, because it can mean a univariate (also called scalar or one-dimensional) timeseries or a multivariate (also called multi-dimensional) timeseries. To resolve this confusion, in <strong>DynamicalSystems.jl</strong> we have the following convention: <strong>&quot;timeseries&quot;</strong> is always univariate! it refers to a one-dimensional vector of numbers, which exists with respect to some other one-dimensional vector of numbers that corresponds to a time vector. On the other hand, we use the word <strong>&quot;dataset&quot;</strong> is used to refer to a <em>multi-dimensional</em> timeseries, which is of course simply a group/set of one-dimensional timeseries represented as a <a href="#StateSpaceSets.StateSpaceSet"><code>StateSpaceSet</code></a>. In some documentation strings we use the word &quot;trajectory&quot; instead of &quot;dataset&quot;, which means an ordered multivariate timeseries. This is typically the output of the function <a href="@ref"><code>trajectory</code></a>, or the delay embedding of a timeseries via <a href="@ref"><code>embed</code></a>, both of which are also represented as a <a href="#StateSpaceSets.StateSpaceSet"><code>StateSpaceSet</code></a>.</p></div></div><h2 id="StateSpaceSet"><a class="docs-heading-anchor" href="#StateSpaceSet">StateSpaceSet</a><a id="StateSpaceSet-1"></a><a class="docs-heading-anchor-permalink" href="#StateSpaceSet" title="Permalink"></a></h2><p>Trajectories, and in general sets in state space, are represented by a structure called <code>StateSpaceSet</code> in <strong>DynamicalSystems.jl</strong> (while timeseries are always standard Julia <code>Vector</code>s). It is recommended to always <a href="#StateSpaceSets.standardize"><code>standardize</code></a> datasets.</p><article class="docstring"><header><a class="docstring-binding" id="StateSpaceSets.StateSpaceSet" href="#StateSpaceSets.StateSpaceSet"><code>StateSpaceSets.StateSpaceSet</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StateSpaceSet{D, T} &lt;: AbstractStateSpaceSet{D,T}</code></pre><p>A dedicated interface for sets in a state space. It is an <strong>ordered container of equally-sized points</strong> of length <code>D</code>. Each point is represented by <code>SVector{D, T}</code>. The data are a standard Julia <code>Vector{SVector}</code>, and can be obtained with <code>vec(ssset::StateSpaceSet)</code>. Typically the order of points in the set is the time direction, but it doesn&#39;t have to be.</p><p>When indexed with 1 index, <code>StateSpaceSet</code> is like a vector of points. When indexed with 2 indices it behaves like a matrix that has each of the columns be the timeseries of each of the variables. When iterated over, it iterates over its contained points. See description of indexing below for more.</p><p><code>StateSpaceSet</code> also supports almost all sensible vector operations like <code>append!, push!, hcat, eachrow</code>, among others.</p><p><strong>Description of indexing</strong></p><p>In the following let <code>i, j</code> be integers, <code>typeof(X) &lt;: AbstractStateSpaceSet</code> and <code>v1, v2</code> be <code>&lt;: AbstractVector{Int}</code> (<code>v1, v2</code> could also be ranges, and for performance benefits make <code>v2</code> an <code>SVector{Int}</code>).</p><ul><li><code>X[i] == X[i, :]</code> gives the <code>i</code>th point (returns an <code>SVector</code>)</li><li><code>X[v1] == X[v1, :]</code>, returns a <code>StateSpaceSet</code> with the points in those indices.</li><li><code>X[:, j]</code> gives the <code>j</code>th variable timeseries (or collection), as <code>Vector</code></li><li><code>X[v1, v2], X[:, v2]</code> returns a <code>StateSpaceSet</code> with the appropriate entries (first indices being &quot;time&quot;/point index, while second being variables)</li><li><code>X[i, j]</code> value of the <code>j</code>th variable, at the <code>i</code>th timepoint</li></ul><p>Use <code>Matrix(ssset)</code> or <code>StateSpaceSet(matrix)</code> to convert. It is assumed that each <em>column</em> of the <code>matrix</code> is one variable. If you have various timeseries vectors <code>x, y, z, ...</code> pass them like <code>StateSpaceSet(x, y, z, ...)</code>. You can use <code>columns(dataset)</code> to obtain the reverse, i.e. all columns of the dataset in a tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/61b726d27bb21a9ccc8238eae501988d86bad7a8/src/statespaceset_concrete.jl#L3-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceSets.standardize" href="#StateSpaceSets.standardize"><code>StateSpaceSets.standardize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">standardize(d::StateSpaceSet) → r</code></pre><p>Create a standardized version of the input set where each column is transformed to have mean 0 and standard deviation 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/61b726d27bb21a9ccc8238eae501988d86bad7a8/src/statespaceset.jl#L250-L255">source</a></section><section><div><pre><code class="nohighlight hljs">standardize(x::Timeseries) = (x - mean(x))/std(x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/61b726d27bb21a9ccc8238eae501988d86bad7a8/src/timeseries.jl#L17-L19">source</a></section></article><p>In essence a <code>StateSpaceSet</code> is simply a wrapper for a <code>Vector</code> of <code>SVector</code>s. However, it is visually represented as a matrix, similarly to how numerical data would be printed on a spreadsheet (with time being the <em>column</em> direction). It also offers a lot more functionality than just pretty-printing. Besides the examples in the documentation string, you can e.g. iterate over data points</p><pre><code class="language-julia hljs">using DynamicalSystems
hen = Systems.henon()
data = trajectory(hen, 10000) # this returns a dataset
for point in data
    # stuff
end</code></pre><p>Most functions from <strong>DynamicalSystems.jl</strong> that manipulate and use multidimensional data are expecting a <code>StateSpaceSet</code>. This allows us to define efficient methods that coordinate well with each other, like e.g. <a href="@ref"><code>embed</code></a>.</p><h2 id="StateSpaceSet-Functions"><a class="docs-heading-anchor" href="#StateSpaceSet-Functions">StateSpaceSet Functions</a><a id="StateSpaceSet-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#StateSpaceSet-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StateSpaceSets.minima" href="#StateSpaceSets.minima"><code>StateSpaceSets.minima</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">minima(dataset)</code></pre><p>Return an <code>SVector</code> that contains the minimum elements of each timeseries of the dataset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/61b726d27bb21a9ccc8238eae501988d86bad7a8/src/statespaceset.jl#L173-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceSets.maxima" href="#StateSpaceSets.maxima"><code>StateSpaceSets.maxima</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">maxima(dataset)</code></pre><p>Return an <code>SVector</code> that contains the maximum elements of each timeseries of the dataset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/61b726d27bb21a9ccc8238eae501988d86bad7a8/src/statespaceset.jl#L190-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceSets.minmaxima" href="#StateSpaceSets.minmaxima"><code>StateSpaceSets.minmaxima</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">minmaxima(dataset)</code></pre><p>Return <code>minima(dataset), maxima(dataset)</code> without doing the computation twice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/61b726d27bb21a9ccc8238eae501988d86bad7a8/src/statespaceset.jl#L207-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceSets.columns" href="#StateSpaceSets.columns"><code>StateSpaceSets.columns</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">columns(ssset) -&gt; x, y, z, ...</code></pre><p>Return the individual columns of the state space set allocated as <code>Vector</code>s. Equivalent with <code>collect(eachcol(ssset))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/61b726d27bb21a9ccc8238eae501988d86bad7a8/src/statespaceset.jl#L39-L44">source</a></section></article><h2 id="StateSpaceSet-distances"><a class="docs-heading-anchor" href="#StateSpaceSet-distances">StateSpaceSet distances</a><a id="StateSpaceSet-distances-1"></a><a class="docs-heading-anchor-permalink" href="#StateSpaceSet-distances" title="Permalink"></a></h2><h3 id="Two-datasets"><a class="docs-heading-anchor" href="#Two-datasets">Two datasets</a><a id="Two-datasets-1"></a><a class="docs-heading-anchor-permalink" href="#Two-datasets" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="StateSpaceSets.set_distance" href="#StateSpaceSets.set_distance"><code>StateSpaceSets.set_distance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">set_distance(ssset1, ssset2 [, distance])</code></pre><p>Calculate a distance between two <code>StateSpaceSet</code>s, i.e., a distance defined between sets of points, as dictated by <code>distance</code>.</p><p>Possible <code>distance</code> types are:</p><ul><li><a href="#StateSpaceSets.Centroid"><code>Centroid</code></a>, which is the default, and 100s of times faster than the rest</li><li><a href="#StateSpaceSets.Hausdorff"><code>Hausdorff</code></a></li><li><a href="@ref"><code>StrictlyMinimumDistance</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/61b726d27bb21a9ccc8238eae501988d86bad7a8/src/set_distance.jl#L7-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceSets.Hausdorff" href="#StateSpaceSets.Hausdorff"><code>StateSpaceSets.Hausdorff</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Hausdorff(metric = Euclidean())</code></pre><p>A distance that can be used in <a href="#StateSpaceSets.set_distance"><code>set_distance</code></a>. The <a href="https://en.wikipedia.org/wiki/Hausdorff_distance">Hausdorff distance</a> is the greatest of all the distances from a point in one set to the closest point in the other set. The distance is calculated with the metric given to <code>Hausdorff</code> which defaults to Euclidean.</p><p><code>Hausdorff</code> is 2x slower than <a href="@ref"><code>StrictlyMinimumDistance</code></a>, however it is a proper metric in the space of sets of state space sets.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/61b726d27bb21a9ccc8238eae501988d86bad7a8/src/set_distance.jl#L42-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StateSpaceSets.Centroid" href="#StateSpaceSets.Centroid"><code>StateSpaceSets.Centroid</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Centroid(metric = Euclidean())</code></pre><p>A distance that can be used in <a href="#StateSpaceSets.set_distance"><code>set_distance</code></a>. The <code>Centroid</code> method returns the distance (according to <code>metric</code>) between the <a href="https://en.wikipedia.org/wiki/Centroid">centroids</a> (a.k.a. center of mass) of the sets.</p><p>Besides giving as <code>metric</code> an instance from Distances.jl, you can give any function that takes in two static vectors are returns a positive definite number to use as a distance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/61b726d27bb21a9ccc8238eae501988d86bad7a8/src/set_distance.jl#L21-L30">source</a></section></article><h3 id="Sets-of-datasets"><a class="docs-heading-anchor" href="#Sets-of-datasets">Sets of datasets</a><a id="Sets-of-datasets-1"></a><a class="docs-heading-anchor-permalink" href="#Sets-of-datasets" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="StateSpaceSets.setsofsets_distances" href="#StateSpaceSets.setsofsets_distances"><code>StateSpaceSets.setsofsets_distances</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setsofsets_distances(a₊, a₋ [, distance]) → distances</code></pre><p>Calculate distances between sets of <code>StateSpaceSet</code>s. Here  <code>a₊, a₋</code> are containers of <code>StateSpaceSet</code>s, and the returned distances are dictionaries of of distances. Specifically, <code>distances[i][j]</code> is the distance of the set in the <code>i</code> key of <code>a₊</code> to the <code>j</code> key of <code>a₋</code>. Notice that distances from <code>a₋</code> to <code>a₊</code> are not computed at all (assumming symmetry in the distance function).</p><p>The <code>distance</code> can be as in <a href="#StateSpaceSets.set_distance"><code>set_distance</code></a>. However, <code>distance</code> can also be any arbitrary user function that takes as input two state space sets and returns any positive-definite number as their &quot;distance&quot;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/61b726d27bb21a9ccc8238eae501988d86bad7a8/src/set_distance.jl#L132-L144">source</a></section></article><h2 id="StateSpaceSet-I/O"><a class="docs-heading-anchor" href="#StateSpaceSet-I/O">StateSpaceSet I/O</a><a id="StateSpaceSet-I/O-1"></a><a class="docs-heading-anchor-permalink" href="#StateSpaceSet-I/O" title="Permalink"></a></h2><p>Input/output functionality for an <code>AbstractStateSpaceSet</code> is already achieved using base Julia, specifically <code>writedlm</code> and <code>readdlm</code>. To write and read a dataset, simply do:</p><pre><code class="language-julia hljs">using DelimitedFiles

data = StateSpaceSet(rand(1000, 2))

# I will write and read using delimiter &#39;,&#39;
writedlm(&quot;data.txt&quot;, data, &#39;,&#39;)

# Don&#39;t forget to convert the matrix to a StateSpaceSet when reading
data = StateSpaceSet(readdlm(&quot;data.txt&quot;, &#39;,&#39;, Float64))</code></pre><h2 id="Neighborhoods"><a class="docs-heading-anchor" href="#Neighborhoods">Neighborhoods</a><a id="Neighborhoods-1"></a><a class="docs-heading-anchor-permalink" href="#Neighborhoods" title="Permalink"></a></h2><p>Neighborhoods refer to the common act of finding points in a dataset that are nearby a given point (which typically belongs in the dataset). <strong>DynamicalSystems.jl</strong> bases this interface on <a href="https://julianeighbors.github.io/Neighborhood.jl/dev/">Neighborhood.jl</a>. You can go to its documentation if you are interested in finding neighbors in a dataset for e.g. a custom algorithm implementation.</p><p>For <strong>DynamicalSystems.jl</strong>, what is relevant are the two types of neighborhoods that exist:</p><article class="docstring"><header><a class="docstring-binding" id="Neighborhood.NeighborNumber" href="#Neighborhood.NeighborNumber"><code>Neighborhood.NeighborNumber</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NeighborNumber(k::Int) &lt;: SearchType</code></pre><p>Search type representing the <code>k</code> nearest neighbors of the query (or approximate neighbors, depending on the search structure).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Neighborhood.WithinRange" href="#Neighborhood.WithinRange"><code>Neighborhood.WithinRange</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WithinRange(r::Real) &lt;: SearchType</code></pre><p>Search type representing all neighbors with distance <code>≤ r</code> from the query (according to the search structure&#39;s metric).</p></div></section></article><h2 id="Theiler-window"><a class="docs-heading-anchor" href="#Theiler-window">Theiler window</a><a id="Theiler-window-1"></a><a class="docs-heading-anchor-permalink" href="#Theiler-window" title="Permalink"></a></h2><p>The Theiler window is a concept that is useful when finding neighbors in a dataset that is coming from the sampling of a continuous dynamical system. As demonstrated in the figure below, it tries to eliminate spurious &quot;correlations&quot; (wrongly counted neighbors) due to a potentially dense sampling of the trajectory (e.g. by giving small sampling time in <a href="@ref"><code>trajectory</code></a>).</p><p>The figure below demonstrates a typical <code>WithinRange</code> search around the black point with index <code>i</code>. Black, red and green points are found neighbors, but points within indices <code>j</code> that satisfy <code>|i-j| ≤ w</code> should <em>not</em> be counted as &quot;true&quot; neighbors. These neighbors are typically the same around <em>any</em> state space point, and thus wrongly bias calculations by providing a non-zero baseline of neighbors. For the sketch below, <code>w=3</code> would have been used.</p><p>Typically a good choice for <code>w</code> coincides with the choice an optimal delay time, see <a href="@ref"><code>estimate_delay</code></a>, for any of the timeseries of the dataset.</p><p><img src="theiler.png" alt/></p><h2 id="Samplers"><a class="docs-heading-anchor" href="#Samplers">Samplers</a><a id="Samplers-1"></a><a class="docs-heading-anchor-permalink" href="#Samplers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StateSpaceSets.statespace_sampler" href="#StateSpaceSets.statespace_sampler"><code>StateSpaceSets.statespace_sampler</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">statespace_sampler(rng = Random.GLOBAL_RNG; kwargs...) → sampler, isinside</code></pre><p>Convenience function that creates two functions. <code>sampler</code> is a 0-argument function that generates random points inside a state space region defined by the keywords. <code>isinside</code> is a 1-argument function that decides returns <code>true</code> if the given state space point is inside that region.</p><p>The regions can be:</p><ul><li><strong>Rectangular box</strong>, with edges <code>min_bounds</code> and <code>max_bounds</code>. The sampling of the points inside the box is decided by the keyword <code>method</code> which can be either <code>&quot;uniform&quot;</code> or <code>&quot;multgauss&quot;</code>.</li><li><strong>Sphere</strong>, of <code>spheredims</code> dimensions, radius <code>radius</code> and centered on <code>center</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/61b726d27bb21a9ccc8238eae501988d86bad7a8/src/sampler.jl#L8-L20">source</a></section><section><div><pre><code class="nohighlight hljs">statespace_sampler(grid::NTuple{N, AbstractRange} [, rng])</code></pre><p>If given a <code>grid</code> that is a tuple of ranges, the minimum and maximum of the ranges are used as the <code>min_bounds</code> and <code>max_bounds</code> keywords.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/StateSpaceSets.jl/blob/61b726d27bb21a9ccc8238eae501988d86bad7a8/src/sampler.jl#L43-L47">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 14 April 2023 09:35">Friday 14 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
